* Insert new nodes in-place, so that the string of characters inside a node
  is taken sorted, and we can use binary search or just stop scanning
  once a char greater than the one we are looking for is found.
  This also makes the tree lexicographically ordered which is a huge
  feature to have for certain use cases.
* Test the insertion of strings greater then 512 MB.
* Avoid fixing the parent link if the node is the same, if this makes a speed difference because of the avoided cache miss.
* Handle OOM everywhere. Consider a define to switch checking off if it has
  a measurable performance cost.
* All the low level node management functions should be called radtreeNode...()
* Write a complete unit test, testing with gcov that coverage is 100%.
* Write a fuzzer.
* Check if reclaiming nodes from first to last child is a performance
  improvement in radtreeFree().
* Add an interator: radtreeSeek() to start the iteration at a given element
  (should support and start and stop point, inclusive and exclsive both sides,
   and should be able to see at the start or end of the range. Moreover there
   should be ways to specify first and last elements of the three).
   Iteration should work using radtreeNext() and radtreePrev() to navigate
   the tree, returing the keys and associated values.

   Example:

   radtreeIterator *iterator = radtreeSeek("abc",3,RADTREE_INCL,
                                           "xyz',3,RADTREE_EXCL,
                                           RADTREE_SEEK_START);
   while(radtreeNext(iterator)) {
      printf("key: %.*s, val %p\n", (int)iterator->keylen,
                                    (char*)iterator->key,
                                    iterator->val);
   }
   radtreeFreeIterator(iterator);

   Flags in iterator creation:

   RADTREE_SEEK_START
   RADTREE_SEEK_END
   RADTREE_DEL_SAFE (Rescan the tree at every "next"/"prev" operation)

* Random element function.
